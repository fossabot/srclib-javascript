var execFile = require("child_process").execFile, fs = require('fs'), path = require('path');

// apiDocDir is the directory containing node.js API documentation (doc/api in
// the node.js git repository).
exports.apiDocDir = '/usr/share/doc/nodejs/api';

// apiSrcDir is the directory containing the node.js API modules (lib/ in the
// node.js git repository).
exports.apiSrcDir = 'lib/';

// generateJSPath is the path to the tools/doc/generate.js script in the node.js git
// repository.
exports.generateJSPath = 'tools/doc/generate.js';

exports.listDocSourceFiles = function(cb) {
  return fs.readdir(exports.apiDocDir, function(err, files) {
    if (err) return cb(err);
    return cb(null, files.filter(function(f) { return f[0] != '_' && /\.markdown$/.test(f); }).map(function(f) { return path.join(exports.apiDocDir, f); }).sort());
  });
};

exports.generateDoc = function(markdownFile, cb) {
  // TODO(sqs): transparently handle .markdown.gz files
  var opts = {maxBuffer: 2000*1024};
  var child = execFile(process.execPath /* node */, [exports.generateJSPath, markdownFile], opts, function(err, stdout, stderr) {
    if (err) return cb(err);
    cb(null, JSON.parse(stdout));
  });
};

exports.generateAllDocs = function(cb) {
  exports.listDocSourceFiles(function(err, srcFiles) {
    if (err) return cb(err);
    var all = {sources: []}, failed;
    function srcFileDone(err) {
      if (err) {
        failed = true;
        return cb(err);
      }
      if (!failed && all.sources.length == srcFiles.length) {
        // All done. Sort modules so output is deterministic.
        all.modules.sort(function(a, b) {
          if (a.source == b.source) return 0;
          else if (a.source > b.source) return 1;
          else return -1;
        });
        cb(null, all);
      }
    }
    srcFiles.forEach(function(srcFile) {
      exports.generateDoc(srcFile, function(err, doc) {
        if (err) return srcFileDone(err);
        var source = doc.source;
        delete doc.source;
        doc.modules.forEach(function(m) {m.source = source; });
        Object.keys(doc).forEach(function(key) {
          if (!all[key]) all[key] = [];
          all[key].push.apply(all[key], doc[key]);
        });
        all.sources.push(srcFile);
        srcFileDone();
      });
    });
  });
};

var tern = require('tern');
tern.registerPlugin('node-api-doc', function(server, options) {
  exports.apiDocDir = options.apiDocDir;
  exports.apiSrcDir = options.apiSrcDir;
  exports.generateJSPath = options.generateJSPath;

  function isNodeAPIModule(file) {
    if (!file) return false;
    var apiSrcDir = path.resolve(exports.apiSrcDir);
    var absFile = path.resolve(file);
    return path.dirname(absFile) == apiSrcDir;
  }

  function nodeAPIModuleDocSourceFile(moduleFile) {
    moduleFile = path.basename(moduleFile.replace(/\.js$/, ''));
    moduleFile = path.join(exports.apiDocDir, moduleFile + '.markdown');
    if (fs.existsSync(moduleFile)) return moduleFile;
  }

  // docs is a map of doc source file (*.markdown) to the doc object.
  var docs = {};

  // Set server async and wrap getFile so that we can run an asynchronous
  // operation (generateAllDocs). (This is hacky.)
  var origGetFile0 = server.options.getFile, origGetFile = server.options.getFile;
  if (!server.options.async) origGetFile = function(filename, cb) {
    try {
      var data = origGetFile0(filename);
      cb(null, data);
    } catch (e) {
      cb(e);
    }
  };
  server.options.async = true;
  server.options.getFile = function(filename, cb) {
    var docSrcFile = isNodeAPIModule(filename) ? nodeAPIModuleDocSourceFile(filename) : null;
    if (docSrcFile) {
      exports.generateDoc(docSrcFile, function(err, doc) {
        if (err) throw err;
        docs[docSrcFile] = doc;
        origGetFile(filename, cb);
      })
    } else origGetFile(filename, cb);
  };
  // Also hack addFile so that bin/condense can't bypass our getFile hack
  // (above) by providing the file contents as the 2nd param ("text").
  var origAddFile = server.addFile;
  server.addFile = function(filename) { origAddFile.apply(server, [filename]); };

  return {
    passes: {
      preCondenseReach: function(state) {
        Object.keys(server._node.modules).forEach(function(m) {
          if (!isNodeAPIModule(m)) return;
          var docSourceFile = nodeAPIModuleDocSourceFile(m);
          if (!docSourceFile) return;

          // Treat modules and global definitions the same. (E.g., console is a
          // global, not a module.)
          var topLevelDocObjList = docs[docSourceFile].modules || docs[docSourceFile].globals;
          if (!topLevelDocObjList || topLevelDocObjList.length == 0) return;

          var moduleDocObj = topLevelDocObjList[0];
          var moduleType = server._node.modules[m].getType();
          moduleType.doc = moduleDocObj.desc;
          function traverseAndAssociateDocs(docObj, type, depth) {
            if (depth > 1) return; // don't go too deep
            if (!type || !type.props) return;
            Object.keys(type.props).forEach(function (prop) {
              var childType = type.props[prop];
              if (prop == 'prototype') {
                traverseAndAssociateDocs({methods: docObj.methods}, childType.getType(), depth);
              } else {
                var childDocObj = findDocObj(docObj, prop);
                if (!childDocObj) return null;
                childType.doc = childDocObj.desc;
                traverseAndAssociateDocs(childDocObj, childType.getType(), depth + 1);
              }
            });
          }
          traverseAndAssociateDocs(moduleDocObj, moduleType, 0);
        });
      },
    },
  };
});

function findDocObj(moduleDoc, name) {
  function find(docObjs) {
    if (!docObjs) return;
    return docObjs.filter(function(o) { return o.name == name; })[0];
  }
  return find(moduleDoc.methods) || find(moduleDoc.classes) || find(moduleDoc.properties) || find(moduleDoc.classMethods);
}
